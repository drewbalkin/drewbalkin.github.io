<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>blog - Overview</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./KellyOptimalMarketCycles.html" rel="" target="">
 <span class="menu-text">Valuation-Based Kelly Optimal Portfolios</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-log-optimal-portfolio-and-option-pricing" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Log Optimal Portfolio and Option Pricing</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-log-optimal-portfolio-and-option-pricing">    
        <li>
    <a class="dropdown-item" href="./logoptimal1.html" rel="" target="">
 <span class="dropdown-text">Part 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./logoptimal2.html" rel="" target="">
 <span class="dropdown-text">Part 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./logoptimal3.html" rel="" target="">
 <span class="dropdown-text">Part 3</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#theorems" id="toc-theorems" class="nav-link" data-scroll-target="#theorems">Theorems</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Overview</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>We first introduce a general model and define the growth optimal portfolio associated to it. Such a portfolio can be also called Kelly or log optimal.</p>
<p>First we define <span class="math inline">\(S^i_t\)</span> to be the total return process of asset <span class="math inline">\(i\)</span>. This is so that dividends can be ignored. When we have options on the stock price and not the total return process, we can adjust as needed.</p>
<p>We start by defining a filtration <span class="math inline">\(\mathcal{F}_t\)</span> which represents the information in the market up to and including time <span class="math inline">\(t\)</span>. We then have</p>
<p><span class="math display">\[dS^i_t = \mu^i_t dt + \sum_{j=1}^M \sigma^{i,j}_t dW^j_t.\]</span> for each <span class="math inline">\(i \in \{1, \cdots, N\}\)</span> and also <span class="math display">\[dB_t = r_t B_tdt\]</span> for the money market account.</p>
<p>It is important to note that <span class="math inline">\(\mathcal{F}_t\)</span> is not the filtration generated by the Brownian motion, but one that contains it. <span class="math inline">\(\mu_t\)</span>, <span class="math inline">\(\sigma_t\)</span>, <span class="math inline">\(r_t\)</span> are adapted to the filtration <span class="math inline">\(\mathcal{F_t}\)</span> – not just the Brownian motion. This means that they can depend on some outside information. This includes for instance, a stochastic volatility model as well as any others.</p>
<p>Then generality of this model holds from the generality of <span class="math inline">\(\mu_t\)</span>, <span class="math inline">\(\sigma_t\)</span>, and <span class="math inline">\(r_t\)</span>. This allows for multiple sources of noise (so for instance we can think of APT models) and stochastic volatility.The model considered (HERE) for instance considers earnings and price to earnings multiple as exogenous processes and the stock price process is determined from these two. This would still fit in to this model. The reason the model maybe unrealistic is that it assumes that we actually do know the local mean rates of returns and volatilities at a given time having observed the information up and to this time.</p>
<p>Now, we define a portfolio <span class="math inline">\(\pi_t = (\pi^1_t , \cdots, \pi^N_t)\)</span> which is a process adapted to <span class="math inline">\(\mathcal{F}_t\)</span>. We think of this portfolio in terms of the fraction of wealth allocated to each asset (intuitively: think <span class="math inline">\(\pi_t\)</span> represents the percentage allocations). The money market allocation will be <span class="math inline">\(1 - \sum_i \pi^i_t\)</span>, so that way no additional portfolio constraints must be introduced. With this notation, it is very easy to define self financing portfolios. It just corresponds to any choice of <span class="math inline">\(\pi_t = (\pi^1_t , \cdots, \pi^N_t) \in \mathbb{R}^N\)</span> (we may want to choose a bounded set so things do not explode – this corresponds to leverage constraints). The self-financing portfolio associated to <span class="math inline">\(\pi\)</span>, <span class="math inline">\(V^\pi\)</span>, is easily represented in terms of portfolio return:</p>
<p><span class="math display">\[\frac{dV_t^\pi}{V_t^\pi} = \sum_{i=1}^N \pi^i_t \frac{dS^i_t}{S^i_t} + (1-\sum_{i=1}^N \pi^i_t) r_t dt\]</span></p>
<p>which gives</p>
<p><span class="math display">\[\frac{dV_t^\pi}{V_t^\pi} = \pi_t^T \mu_t dt + \pi_t^T \sigma_t dW_t + (1-\sum_{i=1}^N \pi^i_t) r_t dt\]</span></p>
<p>where <span class="math inline">\(\mu = (\mu^1 , \cdots, \mu^N)\)</span> and <span class="math inline">\(\sigma = (\sigma^{i,j})_{i,j}\)</span>. Without loss of generality, we take <span class="math inline">\(V_0^\pi = 1\)</span> unless stated otherwise.</p>
<p>We now can define the log-optimal portfolio as the argument maximizer out of admissible portfolio processes, <span class="math inline">\((\pi_t)\)</span>, of the expression</p>
<p><span class="math display">\[\mathbb{E}[\log(V_t^\pi)].\]</span></p>
</section>
<section id="theorems" class="level1">
<h1>Theorems</h1>
<blockquote class="blockquote">
<p><strong>Theorem 1</strong> Assume that the claim <span class="math inline">\(\xi\)</span> is attainable. Then its unique arbitrage price is given by <span class="math display">\[\frac{\Pi(t ; \xi)}{V^{\pi^*}_T} = \mathbb{E}^{\mathbb{P}}\left[ \frac{\xi}{V^{\pi^*}_T} \bigg{|} \mathcal{F}_t \right] \]</span> That is, the log-optimal portfolio process is the appropriate numeraire such that option pricing is simply the true expected value (under the real world measure <span class="math inline">\(\mathbb{P}\)</span>!) In other words, if the units of account were simply not dollars, or not bank account, but instead units of log-optimal portfolio, we could simply understand option pricing in the most naive way possible (the expectation of the payout under the true measure)… and it would turn out to be right!</p>
</blockquote>
<p>These results are somewhat known but surprisingly somewhat unknown. Theorem 2 in particular. One can do options pricing without realizing that Theorem 2 provides an alternative method all along for very general models and very general attainable claims.</p>
<p>Lastly, the problem with Theorem 2 is that <span class="math inline">\(\xi\)</span> needs to be attainable. But what if <span class="math inline">\(\xi\)</span> is generally unattainable as would be the case for generic claims in a model when <span class="math inline">\(M &gt; N\)</span> for instance when there are more noises than assets. This is a real world setting. However, we can borrow from utility theory. The idea is that although a claim cannot be hedged, its marginal addition to a portfolio would either add or remove utility for a given investor. This investor (identified by their utility function) has a price of the option such that the marginal utility associate with the addition of the option is <span class="math inline">\(0\)</span>. This would be the investor’s utility price for the option.</p>
<p>To make this more rigorous:</p>
<blockquote class="blockquote">
<p>** Definition 1 ** Consider a claim that pays out <span class="math inline">\(\xi_T\)</span> at time <span class="math inline">\(T\)</span>. Let <span class="math inline">\((U_\alpha,T)\)</span> be the investor’s utility function (indexed by <span class="math inline">\(\alpha\)</span>) for horizon <span class="math inline">\(T\)</span>. This means that the investor selects a portfolio strategy <span class="math inline">\(\pi(\alpha)\)</span> such that <span class="math inline">\(\mathbb{E}[ U_\alpha(V^\pi_T)]\)</span> is maximized.</p>
<p>Then the price <span class="math inline">\(\xi_0(\alpha)\)</span>, called investor <span class="math inline">\((U_\alpha,T)\)</span>’s indifference price for a marginal quantity, satisfies: <span class="math display">\[\frac{d}{d\epsilon} \bigg{|}_{\epsilon = 0} \mathbb{E}\bigg[ U_\alpha \left( (1-\epsilon)V^{\pi(\alpha)}_T + \epsilon \frac{\xi_T}{\xi_0(\alpha)} \right) \bigg] = 0.\]</span></p>
<p>This can be reduced and we write <span class="math display">\[\xi_0(\alpha) = \frac{\mathbb{E}\bigg[ U_\alpha ' \left( V^{\pi(\alpha)}_T \right) \xi_T \bigg]}{\mathbb{E}\bigg[ U_\alpha ' \left( V^{\pi(\alpha)}_T \right) V^{\pi(\alpha)}_T \bigg] }.\]</span></p>
</blockquote>
<p>Now we have the very powerful result.</p>
<blockquote class="blockquote">
<p><strong>Theorem 2</strong> Let <span class="math inline">\((U_\gamma,T)\)</span> be the investor’s utility function for time horizon <span class="math inline">\(T\)</span>. In this case we take <span class="math inline">\(U_\gamma\)</span> to be any CRRA utility function <span class="math inline">\(U_\gamma(x) = \gamma x^\gamma\)</span> for <span class="math inline">\(\gamma &lt; 1\)</span>. We claim that <span class="math inline">\(\xi_0(\gamma)\)</span> does not depend on <span class="math inline">\(\gamma\)</span> and moreover,</p>
</blockquote>
<p><span class="math display">\[\chi_0(\alpha) = \chi_0 = \mathbb{E}^{\mathbb{P}}\left[ \frac{\chi_T}{V^{\pi^*}_T} \right].\]</span></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>