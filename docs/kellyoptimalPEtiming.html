<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>blog - Kelly Optimal In Earnings Driven Financial Market</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-projects" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Projects</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-projects">    
        <li>
    <a class="dropdown-item" href="./kellyoptimalPEtiming.html" rel="" target="">
 <span class="dropdown-text">Kelly Optimality throughout Market Cycles</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-log-optimal-portfolio-and-option-pricing" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Log Optimal Portfolio and Option Pricing</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-log-optimal-portfolio-and-option-pricing">    
        <li>
    <a class="dropdown-item" href="./logoptimal1.html" rel="" target="">
 <span class="dropdown-text">Part 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./logoptimal2.html" rel="" target="">
 <span class="dropdown-text">Part 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./logoptimal3.html" rel="" target="">
 <span class="dropdown-text">Part 3</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#numerical-solution" id="toc-numerical-solution" class="nav-link" data-scroll-target="#numerical-solution">Numerical Solution</a></li>
  <li><a href="#analytical-solution" id="toc-analytical-solution" class="nav-link" data-scroll-target="#analytical-solution">Analytical Solution</a></li>
  <li><a href="#backtests" id="toc-backtests" class="nav-link" data-scroll-target="#backtests">Backtests</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Kelly Optimal In Earnings Driven Financial Market</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="abstract" class="level1">
<h1>Abstract</h1>
<p>We consider a Kelly Optimal portfolio allocation depending on PE ratio of an underlying stock index. We assume that the earnings of the index as well as the market multiple are exogenous variables described by SDEs. The earnings of the index are driven by a Geometric Brownian Motion, while the market multiple’s inverse, the earnings yield, is driven by an Ornstein-Uhlenbeck process with parameters determined from historical data. We construct the Kelly optimal portfolio through neural networks as well as analytically. The results are back-tested on CAPE and PE ratio data.</p>
<p>The purpose is not to showcase or recommend a strategy that is necessarily good or bad. The purpose is to highlight how neural networks can be used to successfully solve portfolio optimization problems. One could imagine a much more complicated (and more realistic) model for which one could find an optimal portfolio strategy via this approach.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>We can think of our ownership of a stock at time <span class="math inline">\(t\)</span> as a claim on the future dividends <span class="math inline">\((D_s)_{s \geq t}\)</span>, where the amount <span class="math inline">\(D_s ds\)</span> per share is paid to the stockholder’s over time <span class="math inline">\([s,s+ds]\)</span>. This gives a (naive) valuation formula</p>
<p><span class="math display">\[S_t = \int_t^{\infty}  \mathbb{E}^Q [ e^{-r(s-t)} D_s ds ],\]</span> where <span class="math inline">\(Q\)</span> is the risk-neutral measure. The problem is that 1. We don’t know the risk neutral-measure. It would have to be calibrated from market prices. 2. Market preferences for risk vary with time meaning that <span class="math inline">\(Q\)</span> itself varies with time.</p>
<p>However, we can take this pricing formula as motivation. There are 3 factors that are going to impact the stock return at time <span class="math inline">\(t\)</span>:</p>
<ol type="1">
<li>The dividend return</li>
<li>The change in dividends (i.e.&nbsp;recession / growth). More generally, the probability distribution of future dividends changes as new information is introduced.</li>
<li>The market value for future dividends (change in multiple). More generally, the change in <span class="math inline">\(Q\)</span> over time as investors change their risk preferences.</li>
</ol>
<p>So one component of the return (and the stochastic nature of the stock return) is from directly receiving the random stochastic payments given by the process <span class="math inline">\((D_t)\)</span>.</p>
<p>The second component of return is that this probabilistic future stream of dividends changes over time. That is the outlook changes so the probability distribution of these dividends change as well. This causes a price change as the market reacts to how the dividend changes throughout time.</p>
<p>However, there is a third component to return. Even if the probability distribution of future dividends were not to change over a time interval <span class="math inline">\([t,t+dt]\)</span>, it is still possible that the market is willing to change its mind and pay a different price for this exact same stream of future dividends.</p>
<p>In our model, we will model the first component through the actual payment of dividends, the second component by modelling the dividend process, and the third component by a market multiple process. This corresponds to the three components of total stock return: dividends, dividend growth, and market multiple changes.</p>
<p>Note that a company or stock index may not pay all excess profits or earnings, as dividends. Other options are buybacks, acquisitions, or reinvestment. As for buybacks, we can treat this exactly the same as a reinvested dividend so we can pretend that buybacks are simply a part of the dividend distribution. The other two are not and would affect the dividend growth rate. However, if we assume that acquisitions / reinvestment is done at a similar rate of return as compared to owning the security, we can just assume earnings are just glorified dividends with respect to our model.</p>
<p>From now on, we will treat dividends as earnings. We assume that earnings as a whole are paid out to the investor as if it were a dividend. Afterall the profit at time <span class="math inline">\(t\)</span> is distributed to shareholders one way or another whether it is dividends, buybacks, aquisitions, or reinvestment. It is dangerous to include all of these as “dividend” payments, however it will be critical to the model.</p>
<p>In this model, we will have a stock index whose profits (or dividends by our assumption) at time <span class="math inline">\(t\)</span> is given by the process <span class="math inline">\(D_t\)</span> where <span class="math inline">\(D_tdt\)</span> represents the total dividend payment in <span class="math inline">\([t,t+dt]\)</span> for owning <span class="math inline">\(1\)</span> unit of stock. This dividend process will be given by a GBM with mean <span class="math inline">\(\mu\)</span> and volatility <span class="math inline">\(\sigma_D\)</span>. Seperately, there is a market multiple process <span class="math inline">\(M_t\)</span> which represents the amount the market is willing to pay for the stock given its current dividend. Simply, if <span class="math inline">\(S_t\)</span> is stock price at time <span class="math inline">\(t\)</span>, then <span class="math inline">\(D_t M_t = S_t\)</span>. To model the market multiple process, we model its inverse, the dividend yield process <span class="math inline">\(y_t = \frac{1}{M_t} = \frac{D_t}{S_t}\)</span> with an OU model, which is common for interest rates. This gives the model</p>
<p><span class="math display">\[\begin{align}
dD_t = \mu D_t dt + \sigma_D D_t dW^1_t \\
dy_t = -\theta(y_t-y_{eq})dt + \sigma_y dW^2_t
\end{align}\]</span></p>
<p>We assume for now that the Brownian motions <span class="math inline">\(W^1,W^2\)</span> are independent although this is not entirely representative of reality. The model parameters <span class="math inline">\(\mu,\sigma_D,\theta,y_{eq},\sigma_y\)</span> will eventually be calibrated to Shiller’s data for SP500 earnings.</p>
<p>From our exogenous dividend and dividend yield processes, we have an endogenous stock price process as <span class="math inline">\(S_t = \frac{D_t}{y_t}\)</span>. Now we can model our full problem. Let <span class="math inline">\(X_t\)</span> be the investor’s wealth at time and <span class="math inline">\(\pi_t\)</span> be the fraction of wealth in which the investor invests in the stock index.</p>
<p>Over time <span class="math inline">\([t,t+dt]\)</span> the investor will receive dividends equal to the amount of <span class="math inline">\(\pi_t X_t y_t dt\)</span> as they have <span class="math inline">\(\pi_t X_t\)</span> invested in the stock which has a dividend yield of <span class="math inline">\(y_t\)</span>. What is meant by dividend yield here is the instantaneous dividend yield. If <span class="math inline">\(t\)</span> is measured in years where <span class="math inline">\(t=1\)</span> for instance is 1 year, then the annualized dividend yield. The second aspect of P&amp;L over <span class="math inline">\([t,t+dt]\)</span> is given by the change in stock price– the price return. The price return consists of price change due to dividend change (i.e.&nbsp;dividend growth) and also market multiple changes. Simply however, we can calculate it as follows. The stock price return is <span class="math inline">\(\frac{dS_t}{S_t}\)</span> and <span class="math inline">\(\pi_t X_t\)</span> is invested in the stock so the P&amp;L from stock price change is given by <span class="math inline">\(\pi_t X_t \frac{dS_t}{S_t}\)</span>. Adding these two components of P&amp;L together we get that <span class="math inline">\(dX_t = \pi_t X_t y_t dt + \pi_t X_t \frac{dS_t}{S_t}\)</span>.</p>
<p>Writing this in terms of our exogenous variables <span class="math inline">\(D_t\)</span> and <span class="math inline">\(y_t\)</span>, we get that the dynamics for the wealth process <span class="math inline">\(X_t\)</span> are given by:</p>
<p><span class="math display">\[dX_t = \pi_t X_t y_t dt + \pi_t X_t \frac{d(D_t/y_t)}{D_t/y_t}\]</span></p>
<p>Applying Ito’s lemma, we get that</p>
<p><span class="math display">\[dX_t = \pi_t X_t y_t dt + \pi_t X_t \frac{dD_t}{D_t} + \pi_t X_t \frac{d(1/y_t)}{1/y_t} + \pi_t X_t \frac{dD_t d(1/y_t)}{D_t/y_t} \]</span></p>
<p>The last term is <span class="math inline">\(0\)</span> as we assume <span class="math inline">\(dW^1_t dW^2_t = 0\)</span>. Thus we get</p>
<p><span class="math display">\[dX_t = \pi_t X_t y_t dt + \pi_t X_t\frac{dD_t}{D_t} + \pi_t X_t \frac{d(1/y_t)}{1/y_t}  \]</span></p>
<p>Factoring out the total stock allocation <span class="math inline">\(\pi_t X_t\)</span>, we see that this is saying that the return of investing in a stock is given by <span class="math display">\[ y_t dt +  \frac{dD_t}{D_t} + \frac{d(1/y_t)}{1/y_t}\]</span> which is the dividend yield percent + percent dividend growth rate + percent change in multiple.</p>
<p>Anyway we are concerned with the following problem:</p>
<p><span class="math display">\[\begin{align}
dD_t &amp; = \mu D_t dt + \sigma_D D_t dW^1_t \\
dy_t &amp; = -\theta(y_t-y_{eq})dt + \sigma_y dW^2_t\\
dX_t &amp; = \pi_t X_t y_t dt + \pi_t X_t \frac{dD_t}{D_t} + \pi_t X_t \frac{d(1/y_t)}{1/y_t}\\
\end{align}\]</span></p>
<p><span class="math display">\[\max_{\pi} E[U(X_T)]\]</span></p>
<p>for some utility function <span class="math inline">\(U\)</span>. We will consider the Kelly optimal portfolio allocation given by taking <span class="math inline">\(U\)</span> to be <span class="math inline">\(\log(\cdot)\)</span>. This will give the growth optimal portfolio.</p>
</section>
<section id="numerical-solution" class="level1">
<h1>Numerical Solution</h1>
<p>We wish to numerically approach the stochastic optimal control problem:</p>
<p><span class="math display">\[\begin{align}
dD_t &amp; = \mu D_t dt + \sigma_D D_t dW^1_t \\
dy_t &amp; = -\theta(y_t-y_{eq})dt + \sigma_y dW^2_t\\
dX_t &amp; = \pi_t X_t y_t dt + \pi_t X_t \frac{dD_t}{D_t} + \pi_t X_t \frac{d(1/y_t)}{1/y_t}\\
\end{align}\]</span></p>
<p><span class="math display">\[\max_{\pi} E[U(X_T)].\]</span></p>
<p>This can be done using neural networks as follows.</p>
<p>First we assume that we are looking for closed loop feedback form controls that is <span class="math inline">\(\pi_t = \pi(D_t,y_t,X_t,t)\)</span>. In other words, we decide our portfolio allocation based on the current state of our wealth, the dividend, and dividend yield, and the current time. Logically, we should expect to see that in reality <span class="math inline">\(\pi_t = \pi(t,y_t)\)</span>. That is the only relevant information to decide the portfolio allocation should be the current time <span class="math inline">\(t\)</span> (because the model ends at time <span class="math inline">\(T\)</span>) and the current dividend yield <span class="math inline">\(y_t\)</span> as we decide whether we think stocks are expensive or not, as well as how important that is to the portfolio allocation. Since we are calculating the expected value of the <span class="math inline">\(\log(\cdot)\)</span>, a myopic utility function, it will turn out the true optimal portfolio does not depend on time <span class="math inline">\(t\)</span>, but only dividend yield <span class="math inline">\(y_t\)</span>. However, for our numerical approach, this is not necessary and we can pretend we did not know any better.</p>
<p>Assuming that these are the only factors that matter, let us look for the optimal control <span class="math inline">\(\pi_t = \pi(t,y_t)\)</span>. We approximate the optimal control by looking for the optimal control in a class of neural networks.</p>
<p>Thus we are solving the following problem. Let <span class="math inline">\(\pi_{NN}(t,y_t;\theta)\)</span> be a neural network with parameters <span class="math inline">\(\theta\)</span> that inputs <span class="math inline">\((t,y_t)\)</span> and maps it to the fraction portfolio allocation to stocks. Then for this <span class="math inline">\(\pi_{NN}(\cdot,\cdot;\theta)\)</span> we will get a corresponding distribution of final wealth states <span class="math inline">\(X_T\)</span> for this choice of control. We can then calculate the reward function <span class="math inline">\(E[log(X_T)]\)</span> for this choice of control and then optimize the control by performing gradient ascent on the reward function.</p>
<p>We will be doing this optimization in PyTorch. First let us create a neural network architecture that takes two inputs <span class="math inline">\(t\)</span> and <span class="math inline">\(y\)</span> and has a single real valued output.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch <span class="im">import</span> nn</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Model(nn.Module):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Standard NN</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential( </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            nn.Linear(<span class="dv">2</span>,<span class="dv">64</span>), </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            nn.Sigmoid(), </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            nn.Linear(<span class="dv">64</span>, <span class="dv">64</span>), </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            nn.Sigmoid(),</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            nn.Linear(<span class="dv">64</span>, <span class="dv">1</span>), </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            nn.Sigmoid() <span class="co">#bounds alloc between 0% and 300% (see final output) as to not short or get too leveraged. This makes simulations / training run smoothly.           </span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>,z):</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">3</span><span class="op">*</span><span class="va">self</span>.net(z)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>pi_NN <span class="op">=</span> Model()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With our neural network portfolio control <span class="math inline">\(\pi_{NN}(t,y_t;\theta)\)</span> defined, let us simulate the dynamics of the wealth process under this choice of portfolio allocation. We will numerically simulate:</p>
<p><span class="math display">\[\begin{align}
dD_t &amp; = \mu D_t dt + \sigma_D D_t dW^1_t \\
dy_t &amp; = -\theta(y_t-y_{eq})dt + \sigma_y dW^2_t\\
dX_t &amp; = \pi_{NN}(t,y_t) X_t \bigg(y_t dt +  \frac{dD_t}{D_t} + \frac{d(1/y_t)}{1/y_t}\bigg)\\
\end{align}\]</span></p>
<p><span class="math display">\[\max_{\pi} E[\log(X_T)].\]</span></p>
<p>Here, the maximum is with respect to the neural networks in our hypothesis class. That is we are finding the neural network parameters <span class="math inline">\(\theta\)</span> corresponding to a strategy that is close to Kelly optimal (subject to our conditions). We will optimize <span class="math inline">\(\theta\)</span> by usual gradient descent based training. In our case, we will use the Adam optimization.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">20</span> <span class="co">#Choice of final time for ODE.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>N_steps <span class="op">=</span> <span class="dv">100</span> <span class="co">#Number of time discretizations of ODE.</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>N_sim <span class="op">=</span> <span class="dv">2</span><span class="op">**</span><span class="dv">10</span> <span class="co">#number of simulations to do in calculating expected log wealth.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>N_epochs <span class="op">=</span> <span class="dv">5000</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T<span class="op">/</span>N_steps <span class="co">#size of dt for euler scheme</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">#parameters</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">#Recallebrate y_eq etc because I dont think it was taken from cont compounded yields</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">#mu = .01053 #calibrated from real earnings data</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> <span class="fl">.01</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>sigma_D <span class="op">=</span> <span class="fl">.1295</span> <span class="co">#calibrated from real earnings data</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> <span class="fl">.126</span> <span class="co">#calibrated from 1/PE 1860-1990</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>sigma_y <span class="op">=</span> <span class="fl">.01288</span> <span class="co">#calibrated from 1/PE 1860-1990</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">#y_eq = 0.0783 #calibrated from 1/PE 1860-1990</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>y_eq <span class="op">=</span> <span class="fl">0.075</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>opt <span class="op">=</span> torch.optim.Adam(pi_NN.parameters(), lr<span class="op">=</span><span class="fl">.001</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>Losses <span class="op">=</span> []</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(N_epochs):</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    dW1 <span class="op">=</span> torch.randn(N_sim,N_steps)<span class="op">*</span>np.sqrt(dt)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    dW2 <span class="op">=</span> torch.randn(N_sim,N_steps)<span class="op">*</span>np.sqrt(dt)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.empty(N_steps<span class="op">+</span><span class="dv">1</span>,<span class="st">'O'</span>) <span class="co">#preallocating X. 'O' is so that it stores objects. It will be a numpy array of torch tensors</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.empty(N_steps<span class="op">+</span><span class="dv">1</span>,<span class="st">'O'</span>)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> np.empty(N_steps<span class="op">+</span><span class="dv">1</span>,<span class="st">'O'</span>)</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.empty(N_steps<span class="op">+</span><span class="dv">1</span>,<span class="st">'O'</span>)</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    pi_val <span class="op">=</span> np.empty(N_steps,<span class="st">'O'</span>)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    X[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">*</span>torch.ones(N_sim).unsqueeze(<span class="dv">1</span>) <span class="co">#initial condition represents X(0) = 1. Let's just start with $1</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    y[<span class="dv">0</span>] <span class="op">=</span> (<span class="fl">.025</span><span class="op">*</span>torch.randn(N_sim)<span class="op">+</span><span class="fl">.07</span>).unsqueeze(<span class="dv">1</span>).clamp_min(<span class="fl">0.005</span>)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    D[<span class="dv">0</span>] <span class="op">=</span> torch.ones(N_sim).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,N_steps):</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>        t[i] <span class="op">=</span> i<span class="op">*</span>dt<span class="op">*</span>torch.ones(N_sim).unsqueeze(<span class="dv">1</span>) <span class="co">#Now, t[i] is the usual time given i steps but stored as a tensor. t is a numpy array of these 1d tensors.</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>        ty <span class="op">=</span> torch.cat((t[i],y[i]),<span class="dv">1</span>) <span class="co">#this is (t,y) but as a torch tesnor. We concatenated to tensors into a new one.</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">#ty = torch.cat((t[i],y[i],D[i],X[i]),1)</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        pi_val[i] <span class="op">=</span> pi_NN(ty) <span class="co">#we get our current portfolio alloc given this y</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>        <span class="co">#Now we do an ODE step</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>        D[i<span class="op">+</span><span class="dv">1</span>]  <span class="op">=</span> D[i] <span class="op">+</span> mu<span class="op">*</span>D[i]<span class="op">*</span>dt <span class="op">+</span> sigma_D<span class="op">*</span>D[i]<span class="op">*</span>dW1[:,i].unsqueeze(<span class="dv">1</span>)</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>        y[i<span class="op">+</span><span class="dv">1</span>]  <span class="op">=</span> y[i] <span class="op">-</span>theta<span class="op">*</span>(y[i]<span class="op">-</span>y_eq)<span class="op">*</span>dt <span class="op">+</span> sigma_y<span class="op">*</span>dW2[:,i].unsqueeze(<span class="dv">1</span>)</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        y[i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> y[i<span class="op">+</span><span class="dv">1</span>].clamp_min(<span class="fl">0.005</span>) <span class="co">#make 200 multiple as high as we go.... 0.5% div yield.</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>        X[i<span class="op">+</span><span class="dv">1</span>]  <span class="op">=</span> X[i] <span class="op">+</span> pi_val[i]<span class="op">*</span>X[i]<span class="op">*</span>(y[i]<span class="op">*</span>dt <span class="op">+</span> (D[i<span class="op">+</span><span class="dv">1</span>]  <span class="op">-</span> D[i])<span class="op">/</span>D[i] <span class="op">+</span> (<span class="dv">1</span><span class="op">/</span>y[i<span class="op">+</span><span class="dv">1</span>]  <span class="op">-</span> <span class="dv">1</span><span class="op">/</span>y[i])<span class="op">*</span>y[i])</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        X[i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> X[i<span class="op">+</span><span class="dv">1</span>].clamp_min(<span class="dv">0</span>) <span class="co">#ReLU so that if X is negative it gets replaced by 0</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    Loss <span class="op">=</span> <span class="op">-</span> <span class="bu">sum</span>(torch.log(X[<span class="op">-</span><span class="dv">1</span>]<span class="op">+</span><span class="dv">2</span><span class="op">**</span>(<span class="op">-</span><span class="dv">52</span>)))<span class="op">/</span>N_sim </span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    Loss.backward()</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    opt.step()</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    opt.zero_grad()</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    Losses.append(Loss.item())</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>ax.plot(Losses, label<span class="op">=</span><span class="st">'Training Loss'</span>)</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Training Loss Over Time'</span>)</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Epoch'</span>)</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Loss'</span>)</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="kellyoptimalPEtiming_files/figure-html/cell-3-output-1.png" width="600" height="449"></p>
</div>
</div>
<p>We note that simulating portfolios has one problem. Although we have defined our portfolio to be one of finite leverage as our neural network output is not allowed to employ over <span class="math inline">\(300\%\)</span> alloaction to the risky asset, it is still possible that a blow up occurs. To combat this, we employ 1. an adjustment to the earnings yield process that makes it impossible for the stock market to trade above 200x earnings (this will be incorporated in optimal portfolio strategies) 2. an adjustment to wealth such that if the wealth were to go negative, it will remain at <span class="math inline">\(0\)</span> for all time. This will make the log undefined so we have to add a very small amount <span class="math inline">\(2^{-52}\)</span> to the loss function so that the log-wealth is always defined even for the trainings which cause wealth to go to <span class="math inline">\(0\)</span>.</p>
<p>With our trained network, we can now see what the Kelly optimal allocation behaves on some generated data. Keep in mind our adjustments to the dynamics mean that this will not exactly be Kelly for our first proposed model, but a slightly altered model.</p>
<div class="cell" data-execution_count="3">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.ticker <span class="im">as</span> mtick</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set the number of seeds to plot</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    num_seeds <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set the color map to use for the lines</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    colormap <span class="op">=</span> plt.cm.viridis</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="fl">9.5</span>, <span class="fl">5.5</span>))</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Loop over the seeds</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> seed <span class="kw">in</span> <span class="bu">range</span>(num_seeds):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate a color for the current seed</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> colormap(seed <span class="op">/</span> num_seeds)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N_steps<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        x_tens <span class="op">=</span> torch.Tensor(N_steps, N_sim)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        torch.stack(<span class="bu">list</span>(X), out<span class="op">=</span>x_tens)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        x_plt <span class="op">=</span> x_tens.numpy()</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>, <span class="dv">0</span>].plot(t, x_plt[:, seed] <span class="op">/</span> x_plt[<span class="dv">0</span>, seed], label<span class="op">=</span><span class="st">'Scenario </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(seed<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">"Wealth under Kelly allocation rule"</span>)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">"Wealth (Multiple of Initial)"</span>)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>, <span class="dv">0</span>].set_yscale(<span class="st">"log"</span>) </span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        D_tens <span class="op">=</span> torch.Tensor(N_steps, N_sim)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        torch.stack(<span class="bu">list</span>(D), out<span class="op">=</span>D_tens)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        D_plt <span class="op">=</span> D_tens.numpy()</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>, <span class="dv">0</span>].plot(t, D_plt[:, seed], label<span class="op">=</span><span class="st">'Scenario </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(seed<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">"Index Earnings"</span>)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">"Earnings"</span>)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        y_tens <span class="op">=</span> torch.Tensor(N_steps, N_sim)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        torch.stack(<span class="bu">list</span>(y), out<span class="op">=</span>y_tens)</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        y_plt <span class="op">=</span> y_tens.numpy()</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>, <span class="dv">1</span>].plot(t, <span class="dv">1</span><span class="op">/</span>y_plt[:, seed], label<span class="op">=</span><span class="st">'Scenario </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(seed<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">"Index PE Ratio"</span>)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">"PE Ratio"</span>)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        pi_tens <span class="op">=</span> torch.Tensor(N_steps, N_sim)</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        torch.stack(<span class="bu">list</span>(pi_val), out<span class="op">=</span>pi_tens)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        pi_plt <span class="op">=</span> pi_tens.numpy()</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>, <span class="dv">1</span>].plot(t[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>], pi_plt[:, seed], label<span class="op">=</span><span class="st">'Scenario </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(seed<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">"Kelly Optimal Allocation to Index"</span>)</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">"Allocation (%)"</span>)</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>, <span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(<span class="fl">1.0</span>))</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a <span class="kw">in</span> ax.flat:</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>        a.set_xlabel(<span class="st">"Time (years)"</span>)  <span class="co"># Set x-label to 'Time' for all subplots</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>    plt.subplots_adjust(hspace<span class="op">=</span><span class="fl">.5</span>)</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    plt.legend([])  <span class="co"># Remove the legend</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="kellyoptimalPEtiming_files/figure-html/cell-4-output-1.png" width="783" height="486"></p>
</div>
</div>
<p>We see that at higher PE ratios, the Kelly optimal strategy decides to allocate less to the index, while at high PE ratios, the Kelly optimal strategy has a leveraged allocation to the index which is inutitive especially given the model dynamics which models in mean reversion of PE ratios.</p>
<p>Let’s see what the neural network optimal control decides to allocate to equities for a given market multiple. We run this experiment in 3 stages of time. At year 0, at year 5, at year 10.</p>
<div class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.ticker <span class="im">as</span> mtick</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> []</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    N_points <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> seed <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">10</span>]:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> (seed)<span class="op">*</span>torch.ones(N_points).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> torch.linspace(<span class="fl">.02</span>,<span class="fl">.2</span>,N_points).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        ty <span class="op">=</span> torch.cat((t,y),<span class="dv">1</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        pi.append(pi_NN(ty))</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set the number of seeds to plot</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    num_seeds <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set the color map to use for the lines</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    colormap <span class="op">=</span> plt.cm.viridis</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    plt.figure(<span class="dv">1</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Loop over the seeds</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> seed <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">10</span>]:</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate a color for the current seed</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> colormap(seed <span class="op">/</span> <span class="dv">10</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        plt.plot(<span class="dv">1</span><span class="op">/</span>y,pi[<span class="bu">int</span>(seed<span class="op">/</span><span class="dv">5</span>)],color<span class="op">=</span>color, label<span class="op">=</span><span class="st">'Year </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(seed))</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'Stock index allocation for given valuation'</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'PE ratio'</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'Allocation'</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    plt.gca().yaxis.set_major_formatter(mtick.PercentFormatter(<span class="fl">1.0</span>))</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="kellyoptimalPEtiming_files/figure-html/cell-5-output-1.png" width="606" height="449"></p>
</div>
</div>
<p>Interestingly, we see that the allocation to equities does not depend on time, only PE, as all the curves overlap. Of course we see some differences in the curves, but this because we are approximating the true Kelly optimal with neural networks! Actually, it turns out we can derive the analytical solution for Kelly Optimal in this case.</p>
</section>
<section id="analytical-solution" class="level1">
<h1>Analytical Solution</h1>
<p>We now present the analytical solution to compare with our trained neural network.</p>
<p>We must solve:</p>
<p><span class="math display">\[\begin{align}
dD_t &amp; = \mu D_t dt + \sigma_D D_t dW^1_t \\
dy_t &amp; = -\theta(y_t-y_{eq})dt + \sigma_y dW^2_t\\
dX_t &amp; = \pi_t X_t\bigg(y_t dt + \frac{dD_t}{D_t} + \frac{d(1/y_t)}{1/y_t} \bigg)\\
\end{align}\]</span></p>
<p><span class="math display">\[\arg \max_{\pi} E[\log(X_T)].\]</span></p>
<p>We are looking for a Markovian control <span class="math inline">\(\pi_t = \pi(t,D_t,y_t,X_t)\)</span>, but we expect the solution to only depend on <span class="math inline">\(y_t\)</span> for reasons addressed earlier.</p>
<p>We proceed by considering <span class="math inline">\(\log(X_t)\)</span>. With Ito’s lemma we have that <span class="math inline">\(d \log(X_t) = \frac{dX_t}{X_t} - \frac{1}{2}\Big( \frac{dX_t}{X_t} \Big)^2\)</span>, which gives:</p>
<p><span class="math display">\[d \log(X_t) = \pi_t \bigg(y_tdt + \frac{dD_t}{D_t} + \frac{d(1/y_t)}{1/y_t} \bigg) - \frac{1}{2} \pi_t^2 \bigg( \Big(\frac{dD_t}{D_t} \Big)^2 + \Big(  \frac{d(1/y_t)}{1/y_t} \Big)^2 \bigg)\]</span> where we have simplified according to <span class="math inline">\(dW^1dW^2 = 0\)</span>.</p>
<p>Computing some of these terms:</p>
<p><span class="math display">\[\frac{d(1/y_t)}{1/y_t} = \Big( \frac{1}{y_t}\theta(y_t-y_{eq}) + \frac{\sigma_y^2}{y_t^2} \Big)dt - \frac{\sigma_y}{y_t}dW^2_t\]</span></p>
<p>This gives us:</p>
<p><span class="math display">\[d \log(X_t) = \pi_t \bigg(y_t + \mu + \frac{1}{y_t}\theta(y_t-y_{eq}) + \frac{\sigma_y^2}{y_t^2} \bigg)dt - \frac{1}{2} \pi_t^2 \bigg( \sigma_D^2 +   \frac{\sigma_y^2}{y_t^2} \bigg)dt + \ "noise \ terms".\]</span></p>
<p>Taking integral and then expectation (the integral against noise has expectation 0), we get:</p>
<p><span class="math display">\[\mathbb{E}[\log(X_t)] =  \log(X_0) + \mathbb{E} \bigg[   \int_0^T \bigg( \pi_t \Big(y_t + \mu + \frac{1}{y_t}\theta(y_t-y_{eq}) + \frac{\sigma_y^2}{y_t^2} \Big) - \frac{1}{2} \pi_t^2 \Big( \sigma_D^2 +   \frac{\sigma_y^2}{y_t^2} \Big) \bigg) dt \bigg].\]</span></p>
<p>This can be maximized by maximizing the integral pointwise for each <span class="math inline">\(t\)</span> (it is a concave down parabola in terms of <span class="math inline">\(\pi\)</span>). Taking the derivative with repsect to <span class="math inline">\(\pi\)</span> and setting <span class="math inline">\(=0\)</span>, we get</p>
<p><span class="math display">\[\pi^*_t = \frac{y_t + \mu + \frac{1}{y_t}\theta(y_t-y_{eq}) + \frac{\sigma_y^2}{y_t^2}}{\sigma_D^2 +   \frac{\sigma_y^2}{y_t^2} }.\]</span></p>
<p>This can be simplified. However, in this form, we see that the top represents the components of return (return due to yield + dividend growth + mean reversion), while the denominator represents the components of variance (dividend variance + market multiple variance).</p>
<p>As expected, we see that <span class="math inline">\(\pi^*_t = \pi^* (y_t)\)</span>. That is the optimal portolio allocation is decided purely based on the current earnings yield.</p>
<p>Keep in mind the yield here <span class="math inline">\(y_t\)</span> is a continuously compounded yield. So saying <span class="math inline">\(y_t = 0.1\)</span> for instance actually corresponds to the annualized rate <span class="math inline">\(e^{y_t} - 1 = 0.105\)</span></p>
<div class="cell" data-execution_count="5">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Plotting:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pi_true(M):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>M</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    top <span class="op">=</span> y <span class="op">+</span> mu <span class="op">+</span> M<span class="op">*</span>theta<span class="op">*</span>(y<span class="op">-</span>y_eq) <span class="op">+</span> M<span class="op">**</span><span class="dv">2</span><span class="op">*</span>sigma_y<span class="op">**</span><span class="dv">2</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    bottom <span class="op">=</span> sigma_D<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> M<span class="op">**</span><span class="dv">2</span><span class="op">*</span>sigma_y<span class="op">**</span><span class="dv">2</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> top<span class="op">/</span>bottom</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pi_true_adjusted(M):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.minimum(pi_true(M),<span class="fl">3.0</span><span class="op">*</span>np.ones(<span class="bu">len</span>(M)))</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the number of seeds to plot</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>num_seeds <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the color map to use for the lines</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>colormap <span class="op">=</span> plt.cm.viridis</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Loop over the seeds</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>t0 <span class="op">=</span> torch.zeros(<span class="dv">21</span>).unsqueeze(<span class="dv">1</span>) <span class="co">#Choose model for year 0. We showed it didn't matter what year.</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> torch.linspace(<span class="fl">.02</span>,<span class="fl">.2</span>,<span class="dv">21</span>).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>ty <span class="op">=</span> torch.cat((t0,y),<span class="dv">1</span>)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>y_NN <span class="op">=</span> pi_NN(ty)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>y_NN <span class="op">=</span> y_NN.detach()</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>plt.figure(<span class="dv">2</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="fl">.02</span>,<span class="fl">.2</span>,<span class="dv">21</span>)</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="dv">1</span><span class="op">/</span>y,pi_true_adjusted(<span class="dv">1</span><span class="op">/</span>y),<span class="st">'b'</span>)</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="dv">1</span><span class="op">/</span>y,y_NN,<span class="st">'g'</span>)</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="fl">.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>,<span class="fl">2.5</span>,<span class="dv">3</span>], [<span class="st">'0%'</span>, <span class="st">'50%'</span>, <span class="st">'100%'</span>, <span class="st">'150%'</span>, <span class="st">'200%'</span>, <span class="st">'250%'</span>,<span class="st">'300%'</span>])</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Stock index allocation for given valuation'</span>)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'PE ratio'</span>)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Allocation'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>Text(0, 0.5, 'Allocation')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="kellyoptimalPEtiming_files/figure-html/cell-6-output-2.png" width="606" height="449"></p>
</div>
</div>
<p>The cause for differences: in our model, we did not allow the PE ratio to go above 200. We also naturually capped the leverage of the NN based control to be <span class="math inline">\(300\%\)</span> whereas here we are rounding the true Kelly control to be maxed at <span class="math inline">\(300\%\)</span> for comparison purposes.</p>
<p>Also we see the bizarre relation where the true Kelly control will start going up at a large enough PE! This is due to a modelling error where we take <span class="math inline">\(y\)</span> to be given by an OU. The problem is that under the OU model, if we isolate the “change in multiple” component to stock price return, <span class="math inline">\(\frac{d(1/y_t)}{1/y_t}\)</span>, we see that there are problems when <span class="math inline">\(y_t\)</span> is near <span class="math inline">\(0\)</span>. When <span class="math inline">\(y_t\)</span> is near <span class="math inline">\(0\)</span>, the change in multiple’s contribution to portfolio return is to have an infinite mean return and infinite variance. This is not true in reality.</p>
<p><span class="math display">\[\frac{d(1/y_t)}{1/y_t} = \Big( \frac{1}{y_t}\theta(y_t-y_{eq}) + \frac{\sigma_y^2}{y_t^2} \Big)dt - \frac{\sigma_y}{y_t}dW^2_t\]</span></p>
<p>Here we see the mean return and volatility of multiple compression / expansion go to infinity as <span class="math inline">\(y_t\)</span> goes to <span class="math inline">\(0\)</span>. This causes a model issue that we believe wouldn’t exist in reality. In our model, we actually make PEs max out at 200, which makes the NN allocation control seem more believable (because it was trained on perhaps a slightly more believable model) than the true Kelly.</p>
</section>
<section id="backtests" class="level1">
<h1>Backtests</h1>
<p>We now perform a backtest of the model.</p>
<div class="cell" data-execution_count="6">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_excel(<span class="st">'PEdata.xlsx'</span>,sheet_name<span class="op">=</span><span class="st">'Sheet1'</span>,header<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    PEdata <span class="op">=</span> df[<span class="dv">4</span>][<span class="dv">5</span>:<span class="dv">1805</span>]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    TotalReturndata <span class="op">=</span> df[<span class="dv">5</span>][<span class="dv">5</span>:<span class="dv">1805</span>]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    IndexRealE <span class="op">=</span> df[<span class="dv">6</span>][<span class="dv">5</span>:<span class="dv">1805</span>]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    PE10data <span class="op">=</span> df[<span class="dv">8</span>][<span class="dv">5</span>:<span class="dv">1805</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    PE <span class="op">=</span> np.array(PEdata) <span class="co">#now PE contains the trailing 12 month PE for every month at a time from 1860s on</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    PE <span class="op">=</span> PE.astype(np.float32)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    PE <span class="op">=</span> torch.tensor(PE)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    PE10 <span class="op">=</span> np.array(PE10data) </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    PE10 <span class="op">=</span> PE10.astype(np.float32)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    PE10 <span class="op">=</span> torch.tensor(PE10)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    TR <span class="op">=</span> np.array(TotalReturndata)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    TR <span class="op">=</span> TR.astype(np.float32)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    TR <span class="op">=</span> torch.tensor(TR)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    TR2 <span class="op">=</span> <span class="dv">0</span><span class="op">*</span>TR</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    IndexRealE <span class="op">=</span> np.array(IndexRealE)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    IndexRealE <span class="op">=</span> IndexRealE.astype(np.float32)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    IndexRealE <span class="op">=</span> torch.tensor(IndexRealE)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    N_steps <span class="op">=</span> <span class="bu">len</span>(TR)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">12</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> dt<span class="op">*</span><span class="bu">len</span>(TR)</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.empty(N_steps,<span class="st">'O'</span>)</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    X_PE10 <span class="op">=</span> np.empty(N_steps,<span class="st">'O'</span>)</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.empty(N_steps<span class="op">-</span><span class="dv">1</span>,<span class="st">'O'</span>)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>    pi_val <span class="op">=</span> np.empty(N_steps,<span class="st">'O'</span>)</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    pi_valPE10 <span class="op">=</span> np.empty(N_steps,<span class="st">'O'</span>)</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    X[<span class="dv">0</span>] <span class="op">=</span> torch.tensor([<span class="fl">1.</span>]).unsqueeze(<span class="dv">1</span>) <span class="co">#initial condition represents X(0) = 10. Let's just start with $10</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    TR2[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    X_PE10[<span class="dv">0</span>] <span class="op">=</span> torch.tensor([<span class="fl">1.</span>]).unsqueeze(<span class="dv">1</span>) <span class="co">#initial condition represents X(0) = 10. Let's just start with $10</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>PE).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    yPE10 <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>PE10).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,N_steps<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>        t[i] <span class="op">=</span> torch.tensor([<span class="fl">10.0</span>]).unsqueeze(<span class="dv">1</span>) <span class="co">#always puts it in year 10 since doesn't know how to handle past year 20 </span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>        ty <span class="op">=</span> torch.cat((t[i],y[i].unsqueeze(<span class="dv">1</span>)),<span class="dv">1</span>) <span class="co">#always puts it in year 5 since doesn't know how to handle past year 20</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>        tyPE10 <span class="op">=</span> torch.cat((t[i],yPE10[i].unsqueeze(<span class="dv">1</span>)),<span class="dv">1</span>)</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>        pi_val[i] <span class="op">=</span> pi_NN(ty) <span class="co">#we get our current portfolio alloc given this y</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>        pi_valPE10[i] <span class="op">=</span> pi_NN(tyPE10) <span class="co">#we get our current portfolio alloc given this y</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">#Now we do an ODE step</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> TR[i<span class="op">+</span><span class="dv">1</span>]<span class="op">/</span>TR[i]<span class="op">-</span><span class="dv">1</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>        X[i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> X[i] <span class="op">+</span> r<span class="op">*</span>pi_val[i]<span class="op">*</span>X[i]</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>        X_PE10[i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> X_PE10[i] <span class="op">+</span> r<span class="op">*</span>pi_valPE10[i]<span class="op">*</span>X_PE10[i] </span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>        TR2[i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> TR2[i] <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>r<span class="op">*</span>TR2[i]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="7">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="fl">9.5</span>, <span class="fl">5.5</span>))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">2021</span><span class="op">-</span>T,<span class="dv">2021</span>,N_steps)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    x_tens <span class="op">=</span> torch.Tensor(N_steps)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    torch.stack(<span class="bu">list</span>(X),out<span class="op">=</span>x_tens)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    x_plt <span class="op">=</span> x_tens.numpy()</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    x_plt <span class="op">=</span> x_plt[:,<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    pi_tens <span class="op">=</span> torch.Tensor(N_steps<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    torch.stack(<span class="bu">list</span>(pi_val[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>]),out<span class="op">=</span>pi_tens)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    pi_plt <span class="op">=</span> pi_tens.numpy()</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    pi_plt <span class="op">=</span> pi_plt[:,<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    TR <span class="op">=</span> np.array(TR)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    TR <span class="op">=</span> TR<span class="op">/</span>TR[<span class="dv">0</span>]</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    startyear <span class="op">=</span> <span class="dv">1871</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    index_start <span class="op">=</span> <span class="bu">int</span>((startyear<span class="op">-</span><span class="dv">1871</span>)<span class="op">/</span>dt)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">0</span>].set_title(<span class="st">'Backtest of optimal portfolio'</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">0</span>].plot(t[index_start:],x_plt[index_start:]<span class="op">/</span>x_plt[index_start],<span class="st">'y'</span>,</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>                 t[index_start:],TR[index_start:]<span class="op">/</span>TR[index_start],<span class="st">'b'</span>)</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">0</span>].set_yscale(<span class="st">"log"</span>)  </span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">1</span>].set_title(<span class="st">'Real Earnings of Index'</span>)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">1</span>].plot(t[index_start:],IndexRealE[index_start:],<span class="st">'g'</span>)</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">1</span>].set_yscale(<span class="st">"log"</span>)  </span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    PE <span class="op">=</span> np.array(PE)    </span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,<span class="dv">1</span>].set_title(<span class="st">'PE ratio'</span>)</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,<span class="dv">1</span>].plot(t[index_start:],PE[index_start:],<span class="st">'r'</span>)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    plt.figure(<span class="dv">4</span>)</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,<span class="dv">0</span>].set_title(<span class="st">'Stock Allocation'</span>)</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,<span class="dv">0</span>].plot(t[index_start:<span class="op">-</span><span class="dv">1</span>],pi_plt[index_start:],<span class="st">'m'</span>)</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>    plt.subplots_adjust(hspace<span class="op">=</span><span class="fl">.5</span>)</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="kellyoptimalPEtiming_files/figure-html/cell-8-output-1.png" width="769" height="468"></p>
</div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Figure size 672x480 with 0 Axes&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="8">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">2021</span><span class="op">-</span>T,<span class="dv">2021</span>,N_steps)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    X_PE10_tens <span class="op">=</span> torch.Tensor(N_steps)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    torch.stack(<span class="bu">list</span>(X_PE10),out<span class="op">=</span>X_PE10_tens)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    X_PE10_plt <span class="op">=</span> X_PE10_tens.numpy()</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    X_PE10_plt <span class="op">=</span> X_PE10_plt[:,<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    startyear <span class="op">=</span> <span class="dv">1871</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    index_start <span class="op">=</span> <span class="bu">int</span>((startyear<span class="op">-</span><span class="dv">1871</span>)<span class="op">/</span>dt)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    piPE10_tens <span class="op">=</span> torch.Tensor(N_steps<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    torch.stack(<span class="bu">list</span>(pi_valPE10[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>]),out<span class="op">=</span>piPE10_tens)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    piPE10_plt <span class="op">=</span> piPE10_tens.numpy()</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    piPE10_plt <span class="op">=</span> piPE10_plt[:,<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    TR <span class="op">=</span> np.array(TR)</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    TR <span class="op">=</span> TR<span class="op">/</span>TR[<span class="dv">0</span>]</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">0</span>].set_title(<span class="st">'Backtest of PE timing (yellow) vs CAPE timing (cyan)'</span>)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">0</span>].plot(t[index_start:],x_plt[index_start:]<span class="op">/</span>x_plt[index_start],<span class="st">'y'</span>,</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>                 t[index_start:],X_PE10_plt[index_start:]<span class="op">/</span>X_PE10_plt[index_start],<span class="st">'c'</span>)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">0</span>].set_yscale(<span class="st">"log"</span>)  </span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">1</span>].set_title(<span class="st">'Real Earnings of Index'</span>)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">1</span>].plot(t[index_start:],IndexRealE[index_start:],<span class="st">'g'</span>)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,<span class="dv">1</span>].set_yscale(<span class="st">"log"</span>)  </span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    PE10 <span class="op">=</span> np.array(PE10)    </span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,<span class="dv">1</span>].set_title(<span class="st">'PE10 ratio'</span>)</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,<span class="dv">1</span>].plot(t[index_start:],PE10[index_start:],<span class="st">'c'</span>)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    plt.figure(<span class="dv">4</span>)</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,<span class="dv">0</span>].set_title(<span class="st">'Stock Allocation'</span>)</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,<span class="dv">0</span>].plot(t[index_start:<span class="op">-</span><span class="dv">1</span>],pi_plt[index_start:],<span class="st">'y'</span>,t[index_start:<span class="op">-</span><span class="dv">1</span>],piPE10_plt[index_start:],<span class="st">'c'</span>)</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>    plt.subplots_adjust(hspace<span class="op">=</span><span class="fl">.5</span>)</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="kellyoptimalPEtiming_files/figure-html/cell-9-output-1.png" width="814" height="431"></p>
</div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Figure size 672x480 with 0 Axes&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="9">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>plt.figure(<span class="dv">1</span>,(<span class="fl">9.5</span>,<span class="dv">5</span>))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Backtest of PE timing (yellow) vs CAPE timing (cyan) and 2x leveraged (blue)'</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>plt.plot(t[index_start:],x_plt[index_start:]<span class="op">/</span>x_plt[index_start],<span class="st">'y'</span>,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>             t[index_start:],X_PE10_plt[index_start:]<span class="op">/</span>X_PE10_plt[index_start],<span class="st">'c'</span>,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>              t[index_start:],TR2[index_start:]<span class="op">/</span>TR2[index_start],<span class="st">'b'</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>plt.yscale(<span class="st">"log"</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="kellyoptimalPEtiming_files/figure-html/cell-10-output-1.png" width="759" height="431"></p>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>